const { Client } = require('@notionhq/client');
const fs = require('fs');
const path = require('path');
const https = require('https');
const crypto = require('crypto');
const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');

// ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú
function loadEnv() {
  const envPath = path.join(process.cwd(), '.env');
  if (fs.existsSync(envPath)) {
    const envContent = fs.readFileSync(envPath, 'utf8');
    envContent.split('\n').forEach(line => {
      const [key, value] = line.split('=');
      if (key && value) {
        process.env[key.trim()] = value.trim();
      }
    });
  }
}

loadEnv();

const notion = new Client({
  auth: process.env.NOTION_TOKEN,
});

const s3Client = new S3Client({
  region: 'ap-northeast-2',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  },
});

const DATABASE_ID = process.env.NOTION_DATABASE_ID;
const S3_BUCKET = 'hyebin-markdown-blog';
const S3_BASE_URL = `https://${S3_BUCKET}.s3.ap-northeast-2.amazonaws.com`;
const CONTENTS_DIR = path.join(process.cwd(), 'contents');

async function notionToMDX() {
  try {
    console.log('üîÑ NotionÏóêÏÑú Î∏îÎ°úÍ∑∏ Í∏ÄÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë...');
    
    // Notion Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Î∞úÌñâÎêú Í∏ÄÎì§ Í∞ÄÏ†∏Ïò§Í∏∞
    const response = await notion.databases.query({
      database_id: DATABASE_ID,
      filter: {
        property: 'Status',
        select: {
          equals: 'Î∞úÌñâ',
        },
      },
      sorts: [
        {
          property: 'Date',
          direction: 'descending',
        },
      ],
    });

    console.log(`üìÑ Ï¥ù ${response.results.length}Í∞úÏùò Í∏ÄÏùÑ Ï∞æÏïòÏäµÎãàÎã§.`);

    let successCount = 0;
    let errorCount = 0;
    const failedPages = [];

    for (const page of response.results) {
      try {
        await processNotionPage(page);
        successCount++;
      } catch (error) {
        errorCount++;
        const title = page.properties['Ïù¥Î¶Ñ']?.title[0]?.text?.content || 'Unknown';
        failedPages.push({ title, error: error.message });
        console.error(`‚ùå "${title}" Ï≤òÎ¶¨ Ïã§Ìå®:`, error.message);
      }
    }

    console.log(`‚úÖ Ï≤òÎ¶¨ ÏôÑÎ£å: ÏÑ±Í≥µ ${successCount}Í∞ú, Ïã§Ìå® ${errorCount}Í∞ú`);

    if (failedPages.length > 0) {
      console.log('\n‚ùå Ïã§Ìå®Ìïú ÌéòÏù¥ÏßÄÎì§:');
      failedPages.forEach(({ title, error }) => {
        console.log(`   - ${title}: ${error}`);
      });
    }

  } catch (error) {
    console.error('‚ùå Notion ÎèôÍ∏∞Ìôî Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
  }
}

async function processNotionPage(page) {
  // ÌéòÏù¥ÏßÄ Ï†ïÎ≥¥ Ï∂îÏ∂ú
  const title = page.properties['Ïù¥Î¶Ñ']?.title[0]?.text?.content || '';
  const slug = page.properties['Slug']?.rich_text[0]?.text?.content || '';
  const category = page.properties['Category']?.select?.name || 'post';
  const date = page.properties['Date']?.date?.start || new Date().toISOString().split('T')[0];
  const description = page.properties['Description']?.rich_text[0]?.text?.content || '';
  const tags = page.properties['Tags']?.multi_select?.map(tag => tag.name) || [];
  
  console.log(`üìù Ï≤òÎ¶¨ Ï§ë: "${title}" (${category})`);

  // ÌéòÏù¥ÏßÄ Î∏îÎ°ùÎì§ Í∞ÄÏ†∏Ïò§Í∏∞
  const blocks = await getAllBlocks(page.id);
  
  // Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Î∞è MDX Î≥ÄÌôò
  const { mdxContent, thumbnailUrl } = await processBlocksToMDX(blocks, slug, category);

  // frontmatter ÏÉùÏÑ±
  const frontmatter = {
    title,
    slug,
    date,
    description,
    thumbnail: thumbnailUrl || '',
    tags
  };

  // MDX ÌååÏùº ÏÉùÏÑ±
  const mdxFile = createMDXFile(frontmatter, mdxContent);

  // ÌååÏùº Ï†ÄÏû•
  await saveMDXFile(mdxFile, slug, category, date);

  console.log(`‚úÖ "${title}" Ï≤òÎ¶¨ ÏôÑÎ£å`);
}

async function getAllBlocks(blockId) {
  let blocks = [];
  let cursor = undefined;

  do {
    const response = await notion.blocks.children.list({
      block_id: blockId,
      start_cursor: cursor,
    });
    blocks.push(...response.results);
    cursor = response.next_cursor;
  } while (cursor);

  return blocks;
}

async function processBlocksToMDX(blocks, slug, category) {
  let mdxContent = '';
  let thumbnailUrl = '';
  let imageCounter = 1;

  for (const block of blocks) {
    switch (block.type) {
      case 'paragraph':
        const paragraphText = await processRichText(block.paragraph.rich_text, slug, category, imageCounter);
        if (paragraphText.content) {
          mdxContent += paragraphText.content + '\n\n';
          imageCounter = paragraphText.imageCounter;
        }
        break;

      case 'heading_1':
        const h1Text = await processRichText(block.heading_1.rich_text, slug, category, imageCounter);
        mdxContent += `# ${h1Text.content}\n\n`;
        imageCounter = h1Text.imageCounter;
        break;

      case 'heading_2':
        const h2Text = await processRichText(block.heading_2.rich_text, slug, category, imageCounter);
        mdxContent += `## ${h2Text.content}\n\n`;
        imageCounter = h2Text.imageCounter;
        break;

      case 'heading_3':
        const h3Text = await processRichText(block.heading_3.rich_text, slug, category, imageCounter);
        mdxContent += `### ${h3Text.content}\n\n`;
        imageCounter = h3Text.imageCounter;
        break;

      case 'bulleted_list_item':
        const bulletText = await processRichText(block.bulleted_list_item.rich_text, slug, category, imageCounter);
        mdxContent += `- ${bulletText.content}\n`;
        imageCounter = bulletText.imageCounter;
        break;

      case 'numbered_list_item':
        const numberedText = await processRichText(block.numbered_list_item.rich_text, slug, category, imageCounter);
        mdxContent += `1. ${numberedText.content}\n`;
        imageCounter = numberedText.imageCounter;
        break;

      case 'code':
        const codeText = block.code.rich_text.map(text => text.text.content).join('');
        const language = block.code.language || 'text';
        mdxContent += `\`\`\`${language}\n${codeText}\n\`\`\`\n\n`;
        break;

      case 'image':
        const imageUrl = await processImage(block.image, slug, category, imageCounter);
        if (imageUrl) {
          const caption = block.image.caption?.map(text => text.text.content).join('') || '';
          mdxContent += `![${caption}](${imageUrl})\n\n`;
          
          // Ï≤´ Î≤àÏß∏ Ïù¥ÎØ∏ÏßÄÎ•º Ïç∏ÎÑ§ÏùºÎ°ú ÏÇ¨Ïö©
          if (!thumbnailUrl) {
            thumbnailUrl = imageUrl;
          }
          imageCounter++;
        }
        break;

      default:
        console.log(`‚ö†Ô∏è  ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∏îÎ°ù ÌÉÄÏûÖ: ${block.type}`);
        break;
    }
  }

  return { mdxContent, thumbnailUrl };
}

async function processRichText(richTextArray, slug, category, imageCounter) {
  let content = '';
  let currentImageCounter = imageCounter;

  for (const richText of richTextArray) {
    if (richText.type === 'text') {
      let text = richText.text.content;
      
      // Ïä§ÌÉÄÏùº Ï†ÅÏö©
      if (richText.annotations.bold) text = `**${text}**`;
      if (richText.annotations.italic) text = `*${text}*`;
      if (richText.annotations.code) text = `\`${text}\``;
      
      content += text;
    }
  }

  return { content, imageCounter: currentImageCounter };
}

async function processImage(imageBlock, slug, category, imageCounter) {
  try {
    let imageUrl = '';
    
    if (imageBlock.type === 'external') {
      imageUrl = imageBlock.external.url;
    } else if (imageBlock.type === 'file') {
      imageUrl = imageBlock.file.url;
    }

    if (!imageUrl) return null;

    console.log(`   üì∏ Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ï§ë: ${imageCounter}.jpg`);
    
    // Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú
    const imageBuffer = await downloadImage(imageUrl);
    
    // S3Ïóê ÏóÖÎ°úÎìú
    const s3Key = `${category}/${slug}/${imageCounter}.jpg`;
    await uploadToS3(imageBuffer, s3Key);
    
    const s3Url = `${S3_BASE_URL}/${s3Key}`;
    console.log(`   ‚úÖ S3 ÏóÖÎ°úÎìú ÏôÑÎ£å: ${s3Url}`);
    
    return s3Url;
  } catch (error) {
    console.error(`   ‚ùå Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ïã§Ìå®:`, error.message);
    return null;
  }
}

async function downloadImage(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (response) => {
      const chunks = [];
      
      response.on('data', (chunk) => {
        chunks.push(chunk);
      });
      
      response.on('end', () => {
        resolve(Buffer.concat(chunks));
      });
      
      response.on('error', (error) => {
        reject(error);
      });
    }).on('error', (error) => {
      reject(error);
    });
  });
}

async function uploadToS3(buffer, key) {
  const command = new PutObjectCommand({
    Bucket: S3_BUCKET,
    Key: key,
    Body: buffer,
    ContentType: 'image/jpeg',
  });

  await s3Client.send(command);
}

function createMDXFile(frontmatter, content) {
  const yamlFrontmatter = Object.entries(frontmatter)
    .map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}: [${value.map(v => `"${v}"`).join(', ')}]`;
      }
      return `${key}: "${value}"`;
    })
    .join('\n');

  return `---\n${yamlFrontmatter}\n---\n\n${content}`;
}

async function saveMDXFile(content, slug, category, date) {
  let filePath;
  
  if (category === 'log') {
    // logÏùò Í≤ΩÏö∞ ÎÇ†ÏßúÎ≥Ñ Ìè¥Îçî Íµ¨Ï°∞
    const dateFolder = date.slice(2, 4) + date.slice(5, 7); // 2024-03-14 -> 2403
    const fileName = date.slice(2).replace(/-/g, '') + '.mdx'; // 2024-03-14 -> 240314.mdx
    
    const logDir = path.join(CONTENTS_DIR, 'log', dateFolder);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    filePath = path.join(logDir, fileName);
  } else {
    // postÏùò Í≤ΩÏö∞ slug Í∏∞Î∞ò
    const postDir = path.join(CONTENTS_DIR, 'post');
    if (!fs.existsSync(postDir)) {
      fs.mkdirSync(postDir, { recursive: true });
    }
    
    filePath = path.join(postDir, `${slug}.mdx`);
  }

  fs.writeFileSync(filePath, content, 'utf8');
  console.log(`   üíæ ÌååÏùº Ï†ÄÏû•: ${filePath}`);
}

// Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
if (require.main === module) {
  notionToMDX();
}

module.exports = { notionToMDX };